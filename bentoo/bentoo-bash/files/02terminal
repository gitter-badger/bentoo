#----------------------------------------------------------------------------
# ~/.bashrc.d/02terminal: executed by .bash_profile for terminal settings
# $Revision: 2.03 $
# $Comment: $
#----------------------------------------------------------------------------

# Prompt management
#----------------------------------------------------------------------------

if [ -f /etc/motd ]; then
	clear
	cat /etc/motd
fi

# Set colorful PS1 only on colorful terminals.
# dircolors --print-database uses its own built-in database
# instead of using /etc/DIR_COLORS or /etc/dircolors.
# Try to use the external file first to take advantage of user additions.
use_color=false
safe_term=${TERM//[^[:alnum:]]/.}	# sanitize TERM

if [ -f /etc/DIR_COLORS ]; then
	grep -q "^TERM ${safe_term}" /etc/DIR_COLORS && use_color=true
elif [ -f /etc/dircolors ]; then
	grep -q "^TERM ${safe_term}" /etc/dircolors && use_color=true
elif [ -f ~/.dir_colors ]; then
	grep -q "^TERM ${safe_term}" ~/.dir_colors && use_color=true
elif type -p dircolors >/dev/null ; then
	if dircolors --print-database | grep -q "^TERM ${safe_term}" ; then
		use_color=true
	fi
fi

if ${use_color} ; then
	if [ ${EUID} == 0 ]; then
		PS1='\[\e[31m\][\[\e[1;31m\]\u\[\e[0m\]@\h \[\e[36m\]\W\[\e[31m\]]\[\e[1;31m\]\$\[\e[0m\] '
	else
		# The variable PROMPT_COMMAND contains a regular bash command that
		# is executed just before the command prompt is displayed.  This
		# variable can be thus used to modify prompt, as it is executed at
		# each time.
		# e.g.: PROMPT_COMMAND=${COMMAND_PROMPT}:+$PROMPT_COMMAND;}
		# 'YOUR COMMAND HERE'
	  #      PS1='\[\e[31m\][\[\e[1;32m\]\u\[\e[00m\]@\h \[\e[36m\]\W\[\e[00m\]\[\e[31m\]]\[\e[00m\]\$ '
		PS1='\[\033[00;32m\]\u\[\033[00;33m\]@\[\033[00;32m\]\h\[\033[01;30m\]:\[\033[01;36m\]\w\[\033[01;37m\]$ \[\033[00m\]'
	fi
#	PROMPT_COMMAND='echo -ne "\033]0;${USER}@${HOSTNAME%%.*}:${PWD/$HOME/~}\007"'
	eval "`dircolors -b`"
	alias ls='ls --color=auto'
	alias dir='ls --color=auto --format=vertical'
	alias vdir='ls --color=auto --format=long'
	alias less='less -r'
else
	if [ ${EUID} == 0 ]; then
		PS1='\[\033[01;36m\]\h \[\033[01;34m\]\W \$ \[\033[00m\]'
	else
		PS1='\[\033[01;36m\]\u@\h \[\033[01;34m\]\W \$ \[\033[00m\]'
	fi
fi

case ${TERM} in
#  xterm*|rxvt*|Eterm|aterm|kterm|gnome*|interix)
#    PROMPT_COMMAND='echo -ne "\033]0;${USER}@${HOSTNAME%%.*}:${PWD/$HOME/~}\007"'
#    export PS1='\[\033[01;36m\]\u@\h \[\033[01;34m\]\w \$ \[\033[00m\]'
#  ;;
  screen)
#    PROMPT_COMMAND='echo -ne "\033_${USER}@${HOSTNAME%%.*}:${PWD/$HOME/~}\033\\"'
#    export PS1='\[\033[01;34m\]\u@\h \[\033[01;36m\]\w \$ \[\033[00m\]'
    PS1='(screen)'$PS1
  ;;
esac

# Enable git prompt
if [ -r /usr/share/git/git-prompt.sh ]; then
    source /usr/share/git/git-prompt.sh
    PS1='$(__git_ps1 "(%s)")'$PS1
elif [ -r /usr/share/git-core/contrib/completion/git-prompt.sh ]; then
    source /usr/share/git-core/contrib/completion/git-prompt.sh
    PS1='$(__git_ps1 "(%s)")'$PS1
fi

# Prompt used in interactive prompt, e.g. when written on several lines with
# \ '> ' is the default.
PS2='> '

# Prompt used when answering to a question asked by script '' is the default.
PS3=''

# Prompt used by "set -x" command in scripts for debug information '+ ' is the
# default.
PS4='+ '

#EOF
